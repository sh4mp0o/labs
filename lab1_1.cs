using System;
using System.IO;

//Скоро начнётся сезон роста бамбука. Скупщики бамбука принимают любое количество бамбука
//каждый день ровно в полдень. Однако цена бамбука каждый день меняется. Нам удалось узнать, по
//какой цене скупщики будут принимать бамбук. Кроме того, мы точно знаем, на сколько метров
//вырастает бамбук за каждые сутки (эта величина тоже меняется). В любой день можно либо срезать
//весь бамбук целиком и продать его, либо оставить бамбук расти дальше. После срезания бамбук
//продолжает расти. Требуется определить, какую максимальную прибыль от продажи бамбука можно
//получить. В полдень нулевого дня (начало сезона роста бамбука) длина бамбука равна 0. Сезон роста
//бамбука длится ровно N суток.
//Входные данные

//В первой строке входного файла находится натуральное число N , 1 ≤ N ≤ 100000 . В каждой
//из следующих N строк содержатся два целых положительных числа, разделенных
//пробелом: цена одного метра бамбука в определенный день и на сколько метров, вырос
//бамбук за последние сутки. В ( i + 1) -й строке файла содержатся данные, относящиеся к
//полудню i – го дня.
//Выходные данные
//В единственной строке выходного файла следует выводить одно целое неотрицательное число –
//наибольшая возможная выручка от продажи бамбука. Гарантируется, что результат не
//превосходит 2
//63 - 1
//.
//Примеры
//входные данные
//8
//2 7
//4 1
//3 3
//5 5
//2 4
//5 2
//4 7
//1 1
//выходные данные
//139
namespace lab01._03._22
{
internal class Program
{
static void Main(string[] args)
{
int n;
int[] cost; int[] count;
using (StreamReader sr = new StreamReader("input.txt"))
{
n = int.Parse(sr.ReadLine());
cost = new int[n]; count = new int[n];
for (int i = 0; i < n; i++)
{
string[] line = sr.ReadLine().Split();
cost[i] = int.Parse(line[0]);
count[i] = int.Parse(line[1]);
}
}
int price = 0; int op = cost[n - 1]; int idx = 0; int cp = 0;
for (int i = n - 1; i > 0; i--)
{
if (cost[i - 1] >= op)
{
for (int j = i; j < n - 1; j++)
{
if (cost[j + 1] < cost[j])
{
price += cost[j] * count[j];
break;
}
else price += op * count[j];
}
op = cost[i - 1];
idx = i - 1;
}
else if (cost[i - 1] < op && i == 1)
{
for (int j = 0; j <= idx; j++)
{
price += op * count[j];
}
}
if(cost[i-1] >= op && i == 1)
{
price += cost[0] * count[0];
}
}
price += cost[n - 1] * count[n - 1];
Console.WriteLine(price);
Console.ReadKey();
}
}
}
